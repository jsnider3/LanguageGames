<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Street Brawler 1992</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #111;
            color: white;
            font-family: monospace;
            overflow: hidden;
        }
        canvas {
            border: 4px solid #444;
            /* Ensures pixelated look for retro feel */
            image-rendering: pixelated;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Kaboom will inject the canvas here -->

    <!-- Load Kaboom.js from CDN -->
    <script type="module">
        // Import Kaboom from the CDN
        import kaboom from "https://unpkg.com/kaboom@3000.0.1/dist/kaboom.mjs";

        // Initialize Kaboom and capture the context
        // When using <script type="module">, the script runs in module scope, not global scope.
        const k = kaboom({
            width: 800,
            height: 450,
            background: [0, 0, 0],
            font: "sinko", // Use a built-in pixel font
            scale: 1.2,
        });

        // FIX: Explicitly destructure all needed Kaboom functions from the context 'k'.
        // This resolves "ReferenceError: clamp is not defined" (and others like rgb, add, etc.) 
        // because it brings these functions into the module's scope.
        const {
            add, anchor, area, body, circle, color, destroy, dt, go, get, height, 
            loadBean, loadSprite, opacity, outline, pos, rect, rgb, rotate, scale, scene, 
            setGravity, sprite, text, time, wait, wave, width,
            z, onCollide, onKeyDown, onKeyPress, onKeyRelease, onUpdate, chance, rand
        } = k;


        // --- CONSTANTS & CONFIGURATION ---
        
        // Helper function - clamp might not be part of Kaboom
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        // Load pixel art sprites
        loadBean(); // Built-in bean sprite as placeholder
        
        // Create a simple pixel art fighter
        const FIGHTER_SPRITE = [
            "..yyyy..",
            ".yyyyyY.",
            ".yyooyy.",
            ".yyyyyY.",
            "..yyyy..",
            "..RRRR..",
            ".RRRRRR.",
            "RRRRRRR.",
            ".RR..RR.",
            "..B..B..",
            "..B..B..",
            ".BB..BB.",
        ];
        
        const FIGHTER_SPRITE_2 = [
            "..cccc..",
            ".cccccc.",
            ".ccoocC.",
            ".cccccc.",
            "..cccc..",
            "..GGGG..",
            ".GGGGGG.",
            "GGGGGGG.",
            ".GG..GG.",
            "..b..b..",
            "..b..b..",
            ".bb..bb.",
        ];
        
        // Define color mappings for sprites
        const SKIN_COLORS = {
            "y": rgb(255/255, 220/255, 177/255), // skin
            "Y": rgb(230/255, 190/255, 140/255), // skin shadow
            "c": rgb(255/255, 220/255, 177/255), // skin
            "C": rgb(230/255, 190/255, 140/255), // skin shadow
            "o": rgb(0, 0, 0),                   // eyes
            ".": null,                           // transparent
        };
        
        const createColorMap = (outfitColor, pantsColor) => ({
            ...SKIN_COLORS,
            "R": outfitColor,
            "G": outfitColor,
            "B": pantsColor,
            "b": pantsColor,
        });
        
        const colorMap1 = createColorMap(
            rgb(200/255, 0, 0),         // red gi
            rgb(100/255, 50/255, 0)     // brown pants
        );
        
        const colorMap2 = createColorMap(
            rgb(0, 150/255, 0),         // green outfit  
            rgb(50/255, 50/255, 50/255) // black pants
        );
        
        // Convert pixel art to sprite data
        function createSpriteFromPixelArt(pixelArt, colorMapping, scale = 6) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = pixelArt[0].length;
            const height = pixelArt.length;
            
            canvas.width = width * scale;
            canvas.height = height * scale;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const char = pixelArt[y][x];
                    const color = colorMapping[char];
                    if (color) {
                        // Kaboom rgb() returns values 0-1, convert to 0-255 for canvas
                        ctx.fillStyle = `rgb(${Math.floor(color.r * 255)}, ${Math.floor(color.g * 255)}, ${Math.floor(color.b * 255)})`;
                        ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
            }
            
            return canvas.toDataURL();
        }
        
        // Sprite configurations
        const SPRITE_CONFIG = {
            player: {
                sprite: FIGHTER_SPRITE,
                colorMap: colorMap1
            },
            enemy1: {
                sprite: FIGHTER_SPRITE_2,
                colorMap: createColorMap(
                    rgb(50/255, 50/255, 150/255),  // dark blue outfit
                    rgb(30/255, 30/255, 80/255)    // darker blue pants
                )
            },
            enemy2: {
                sprite: FIGHTER_SPRITE_2,
                colorMap: createColorMap(
                    rgb(200/255, 30/255, 30/255),  // crimson red outfit
                    rgb(100/255, 20/255, 20/255)   // dark red pants
                )
            },
            enemy3: {
                sprite: FIGHTER_SPRITE_2,
                colorMap: createColorMap(
                    rgb(150/255, 50/255, 200/255), // purple outfit
                    rgb(80/255, 30/255, 100/255)   // dark purple pants
                )
            }
        };
        
        // Load all sprites
        Object.entries(SPRITE_CONFIG).forEach(([name, config]) => {
            loadSprite(name, createSpriteFromPixelArt(config.sprite, config.colorMap));
        });
        
        // Color Constants
        const COLORS = {
            NORMAL_TINT: rgb(255, 255, 255),
            HURT_TINT: rgb(255, 100, 100),
            BLOCK_TINT: rgb(150, 150, 255),
            ATTACK_TINT: rgb(255, 255, 150),
            HEALTH_GREEN: rgb(0, 255, 0),
            HEALTH_YELLOW: rgb(255, 200, 0),
            HEALTH_RED: rgb(255, 0, 0),
            FLOOR: rgb(80, 80, 80),
            HEALTH_BAR_BG: rgb(50, 50, 50),
            PLAYER_COLOR: [0, 200, 200],
        };

        // Movement and Physics Constants
        const PLAYER_SPEED = 350;
        const JUMP_FORCE = 700;
        const GRAVITY_VAL = 1800;
        const FLOOR_HEIGHT = 48;

        // Attack Types
        const ATTACKS = {
            PUNCH: {
                damage: 10,
                range: 60,
                cooldown: 0.4
            },
            KICK: {
                damage: 18,
                range: 85,
                cooldown: 0.7
            }
        };
        const KNOCKBACK_FORCE = 150;
        const BLOCK_REDUCTION = 0.8; // Reduce damage by 80%
        const HIT_STUN_DURATION = 0.3;

        let currentStage = 1;

        // Define the opponents and story progression
        const OPPONENTS = [
            {
                id: 1,
                name: "Street Acolyte",
                color: [100, 100, 255],
                health: 100,
                speed: 250,
                attackRate: 1.5,
                aggression: 0.5,
                intro: "Stage 1: The Street Acolyte approaches. Fight!",
            },
            {
                id: 2,
                name: "Crimson Guard",
                color: [255, 50, 50],
                health: 130,
                speed: 280,
                attackRate: 1.1,
                aggression: 0.7,
                intro: "Acolyte defeated. Now face the relentless Crimson Guard!",
            },
            {
                id: 3,
                name: "The Overseer",
                color: [200, 50, 255],
                health: 180,
                speed: 320,
                attackRate: 0.7, // Boss is faster and more aggressive
                aggression: 0.9,
                intro: "Final Battle! Defeat the Overseer and restore peace.",
            }
        ];

        // --- HELPER FUNCTIONS & COMPONENTS ---
        
        // Game state management
        function resetGame() {
            currentStage = 1;
        }
        
        // UI Helper Functions
        function addCenteredText(content, size, yPos, options = {}) {
            return add([
                text(content, { size, ...options }),
                pos(width() / 2, yPos),
                anchor("center"),
                ...(options.color ? [color(...options.color)] : []),
                ...(options.extraComponents || [])
            ]);
        }

        // Fighter Component Factory (Defines common behaviors for Player and AI)
        function fighter(isPlayer, initialHealth, fighterColor) {
            return {
                id: "fighter",
                // This component requires the entity to also have pos, area, body, color, and anchor components.
                require: ["pos", "area", "body", "color", "anchor"],
                health: initialHealth,
                maxHealth: initialHealth,
                isPlayer: isPlayer,
                isAttacking: false,
                isBlocking: false,
                isHurt: false, // Stunned state
                canAttack: true,
                isFacingRight: isPlayer,
                baseColor: rgb(fighterColor[0], fighterColor[1], fighterColor[2]),

                // Called when the component is added to the entity
                add() {
                    // Ensure the initial color is set correctly (no tint for sprites)
                    this.color = COLORS.NORMAL_TINT;
                },

                // Centralized color update logic
                updateColor() {
                    if (this.health <= 0) return;
                    
                    if (this.isHurt) {
                        // Hurt state manages its own color
                        return;
                    } else if (this.isBlocking) {
                        this.color = COLORS.BLOCK_TINT;
                    } else {
                        this.color = COLORS.NORMAL_TINT;
                    }
                },

                takeDamage(amount, knockbackDir) {
                    if (this.isHurt || this.health <= 0) return;

                    let damageTaken = amount;

                    // Check if blocking
                    if (this.isBlocking) {
                        damageTaken *= (1 - BLOCK_REDUCTION);
                        // Small knockback when blocking
                        this.move(knockbackDir * KNOCKBACK_FORCE * 0.3, 0);
                    } else {
                        // Apply full Knockback and stun if not blocking
                        this.move(knockbackDir * KNOCKBACK_FORCE, 0);
                        // Add a slight vertical hop, reminiscent of MK (1992)
                        if (this.isGrounded()) {
                             this.jump(200); 
                        }

                        this.enterHurtState();
                    }

                    this.health -= damageTaken;
                    this.health = Math.max(0, this.health);

                    // Trigger health update event (for UI)
                    this.trigger("healthUpdate");

                    // Check for Knockout
                    if (this.health <= 0) {
                        this.onDeath();
                    }
                },

                enterHurtState() {
                    this.isHurt = true;
                    this.color = COLORS.HURT_TINT; // Red tint on hit
                    wait(HIT_STUN_DURATION, () => {
                        // Ensure the fighter hasn't died during the stun
                        if (this.health > 0) {
                            this.isHurt = false;
                            // Restore color based on current state
                            this.updateColor();
                        }
                    });
                },

                onDeath() {
                    // Death animation (rotate)
                    this.use(rotate(this.isFacingRight ? 90 : -90));
                    // Remove physics and collision so they don't interfere after death
                    this.unuse("body");
                    this.unuse("area");

                    // Handle scene transition after a delay
                    wait(1.5, () => {
                        if (this.isPlayer) {
                            go("gameOver");
                        } else {
                            // Player wins the stage
                            currentStage++;
                            if (currentStage > OPPONENTS.length) {
                                go("victory");
                            } else {
                                // Go to the next story segment
                                const nextOpponent = OPPONENTS[currentStage - 1];
                                if (nextOpponent) {
                                     go("story", nextOpponent.intro);
                                }
                            }
                        }
                    });
                },

                attack(isKick) {
                    if (!this.canAttack || this.isHurt || this.isBlocking) return;

                    this.isAttacking = true;
                    this.canAttack = false;
                    const attackType = isKick ? ATTACKS.KICK : ATTACKS.PUNCH;
                    const { damage, range, cooldown } = attackType;

                    // Create Hitbox
                    const dir = this.isFacingRight ? 1 : -1;
                    // Position the hitbox in front of the attacker
                    const offsetX = dir * (this.width / 2 + range / 2);
                    const hitboxPos = this.pos.add(offsetX, 0);

                    const hitbox = add([
                        rect(range, 60),
                        pos(hitboxPos),
                        area(),
                        anchor("center"),
                        opacity(0), // Set opacity to 0.5 for debugging hitboxes
                        "hitbox",
                        {
                            damage: damage,
                            ownerId: this.id, // Assign the Kaboom entity ID of the attacker
                        }
                    ]);

                    // Visual feedback for attack (e.g., change color briefly)
                    this.color = COLORS.ATTACK_TINT; // Yellow tint

                    // Attack duration and hitbox removal
                    wait(0.15, () => {
                        destroy(hitbox);
                        this.isAttacking = false;
                        
                        // Restore color logic after attack finishes
                        this.updateColor();
                    });

                    // Cooldown management
                    wait(cooldown, () => {
                        this.canAttack = true;
                    });
                },

                setBlock(blocking) {
                    // Cannot block if currently hurt or in the air
                    if (this.isHurt || !this.isGrounded()) {
                        if (this.isBlocking) {
                             // If previously blocking but now airborne/hurt, reset visuals
                             this.height = 100;
                             // Update color based on current state
                             this.updateColor();
                        }
                        this.isBlocking = false;
                        return;
                    }
                    
                    // Update state only if it changed
                    if (this.isBlocking !== blocking) {
                        this.isBlocking = blocking;
                        if (blocking) {
                            this.height = 70; // Crouch/Block visualization (shorter)
                            // Blue tint to indicate blocking state
                            this.color = COLORS.BLOCK_TINT;
                        } else {
                            this.height = 100; // Reset height
                            // Update color based on current state
                            this.updateColor();
                        }
                    }
                }
            };
        }


        // --- SCENES ---

        // 1. Start Scene
        scene("start", () => {
            addCenteredText("STREET BRAWLER 1992", 48, height() / 4);
            addCenteredText("Your quest is to defeat the three street masters.", 20, height() / 2);
            addCenteredText("CONTROLS:\nA/D - Move | W - Jump | S - Block\nG - Punch | H - Kick", 20, height() * 0.75, {
                align: "center",
                color: [255, 255, 255]
            });

             // Blinking text
             add([
                text("Press ENTER to begin", { size: 24 }),
                pos(width() / 2, height() * 0.9),
                anchor("center"),
                opacity(1),
                {
                    update() {
                        // Wave function creates a smooth oscillation for blinking
                        this.opacity = wave(0, 1, time() * 2);
                    }
                }
            ]);

            onKeyPress("enter", () => {
                resetGame();
                go("story", OPPONENTS[0].intro);
            });
        });

        // 2. Story/Transition Scene
        scene("story", (message) => {
            addCenteredText(message, 24, height() / 2, { width: width() - 100 });
            addCenteredText("Press ENTER to Fight", 22, height() * 0.8);

            onKeyPress("enter", () => {
                go("game", currentStage);
            });
        });

        // 3. Game Scene (The Fight)
        scene("game", (stage) => {
            setGravity(GRAVITY_VAL);
            
            // Safety check for stage validity
            if (stage > OPPONENTS.length || stage < 1) {
                console.error("Invalid stage number:", stage);
                go("start");
                return;
            }
            
            const opponentData = OPPONENTS[stage - 1];

            // --- Setup Arena ---
            // Background (Stage specific coloring for variety)
            const bgColor = stage === 1 ? [40, 30, 50] : stage === 2 ? [50, 30, 30] : [30, 30, 30];
            add([
                rect(width(), height()),
                color(...bgColor),
                pos(0, 0),
                z(-10)
            ]);

            // Floor
            add([
                rect(width(), FLOOR_HEIGHT),
                pos(0, height() - FLOOR_HEIGHT),
                area(),
                body({ isStatic: true }),
                COLORS.FLOOR,
            ]);

            // --- Spawn Characters ---

            // Helper function to create humanoid character
            function createHumanoid(fighterColor, x, isPlayer, spriteName) {
                const char = add([
                    sprite(spriteName),
                    pos(x, height() - FLOOR_HEIGHT - 50),
                    area({ width: 40, height: 70 }),
                    body(),
                    anchor("center"),
                    scale(2), // Make sprites bigger
                    color(255, 255, 255), // White tint (no tinting)
                    fighter(isPlayer, isPlayer ? 100 : opponentData.health, fighterColor),
                ]);
                
                return char;
            }

            // Player
            const player = createHumanoid(COLORS.PLAYER_COLOR, 100, true, "player");

            // Opponent (AI) - select sprite based on stage
            const enemySprite = stage === 1 ? "enemy1" : stage === 2 ? "enemy2" : "enemy3";
            const opponent = createHumanoid(opponentData.color, 700, false, enemySprite);

            // --- UI ---
            add([
                text(`STAGE ${stage}`, { size: 22 }),
                pos(width() / 2, 10),
                anchor("top"),
            ]);

            // Health Bar Helper
            function createHealthBar(x, y, isRightAligned, character) {
                const barWidth = 300;
                // Background/Outline
                add([
                    rect(barWidth + 4, 24),
                    pos(x, y),
                    COLORS.HEALTH_BAR_BG,
                    anchor(isRightAligned ? "topright" : "topleft"),
                ]);

                // The actual health meter
                const bar = add([
                    rect(barWidth, 20),
                    // Offset slightly for the border
                    pos(x + (isRightAligned ? -2 : 2), y + 2),
                    COLORS.HEALTH_GREEN,
                    anchor(isRightAligned ? "topright" : "topleft"),
                    {
                        update() {
                            // Ensure health doesn't visually drop below zero
                            const health = Math.max(0, character.health);
                            const percentage = character.maxHealth > 0 ? (health / character.maxHealth) : 0;
                            this.width = barWidth * percentage;
                            
                            // Color transition: Green -> Yellow -> Red
                            if (percentage < 0.3) this.color = COLORS.HEALTH_RED;
                            else if (percentage < 0.6) this.color = COLORS.HEALTH_YELLOW;
                            else this.color = COLORS.HEALTH_GREEN;
                        }
                    }
                ]);
                return bar;
            }

            createHealthBar(20, 20, false, player);
            createHealthBar(width() - 20, 20, true, opponent);

            add([text("Player", {size: 18}), pos(20, 50), color(255, 255, 255)]);
            add([text(opponentData.name, {size: 18}), pos(width()-20, 50), anchor("topright"), color(255, 255, 255)]);


            // --- Collision Detection (Hitboxes) ---
            // Detect when an object tagged "hitbox" collides with an object using the "fighter" component
            onCollide("hitbox", "fighter", (hitbox, fighter) => {
                // Ensure the fighter isn't hitting themselves (compare entity IDs)
                if (hitbox.ownerId !== fighter.id) {
                    
                    // Determine knockback direction based on the relative position of the hitbox and the fighter.
                    // If the hitbox center is left of the fighter center, the attack came from the left (knockback right = 1)
                    const knockbackDir = hitbox.pos.x < fighter.pos.x ? 1 : -1;

                    fighter.takeDamage(hitbox.damage, knockbackDir);
                    
                    destroy(hitbox); // Destroy the hitbox so it only registers once per attack
                }
            });

            // --- Player Controls ---
            
            // Helper to check if player can perform actions
            const canPlayerAct = () => player.health > 0;
            const canPlayerMove = () => canPlayerAct() && !player.isHurt && !player.isBlocking;

            // Control configuration
            const CONTROLS = {
                movement: {
                    "a": () => canPlayerMove() && player.move(-PLAYER_SPEED, 0),
                    "d": () => canPlayerMove() && player.move(PLAYER_SPEED, 0),
                },
                actions: {
                    "w": () => canPlayerMove() && player.isGrounded && player.isGrounded() && player.jump(JUMP_FORCE),
                    "g": () => canPlayerAct() && player.attack(false), // Punch
                    "h": () => canPlayerAct() && player.attack(true),  // Kick
                },
                block: {
                    down: () => canPlayerAct() && player.setBlock(true),
                    up: () => canPlayerAct() && player.setBlock(false),
                }
            };

            // Register controls
            Object.entries(CONTROLS.movement).forEach(([key, action]) => {
                onKeyDown(key, action);
            });
            
            Object.entries(CONTROLS.actions).forEach(([key, action]) => {
                onKeyPress(key, action);
            });
            
            onKeyDown("s", CONTROLS.block.down);
            onKeyRelease("s", CONTROLS.block.up);

            // --- Game Loop and AI Logic ---
            const AI_CONFIG = {
                ATTACK_RANGE: 110,
                OPTIMAL_DISTANCE: 95,
                BLOCK_DISTANCE: 150,
                BLOCK_DURATION: { min: 0.3, max: 0.6 },
                RETREAT_CHANCE: 0.5,
                RETREAT_SPEED: 0.7
            };
            
            let aiAttackTimer = 0;

            onUpdate(() => {
                // Do not update if the fight is over
                if (player.health <= 0 || opponent.health <= 0) return;

                // 1. Auto-Facing
                // Vector direction from player to opponent
                const direction = opponent.pos.x - player.pos.x;
                
                // Player faces right if opponent is to the right (direction > 0)
                player.isFacingRight = direction > 0;
                // Opponent faces right if player is to the right of them (direction < 0)
                opponent.isFacingRight = direction < 0;

                // 2. Boundary Checks (Keep players on screen)
                [player, opponent].forEach(char => {
                    // Constrain X position. 'clamp' is now correctly defined.
                    char.pos.x = clamp(char.pos.x, char.width / 2, width() - char.width / 2);
                });

                // 3. Ensure blocking stops if airborne or hurt (for player)
                // The setBlock logic handles this internally, but this ensures immediate update if state changes
                if ((!player.isGrounded() || player.isHurt) && player.isBlocking) {
                    player.setBlock(false);
                }

                // 4. AI Behavior
                if (opponent.isHurt) return; // AI cannot act while hurt

                const distance = Math.abs(direction);
                aiAttackTimer += dt();

                // AI Blocking Strategy
                // AI has a chance to block if close and the player is attacking.
                if (distance < AI_CONFIG.BLOCK_DISTANCE && player.isAttacking && chance(0.4 * (1 - opponentData.aggression))) {
                     if (opponent.isGrounded() && !opponent.isBlocking) {
                         opponent.setBlock(true);
                         // Hold the block briefly (0.3s to 0.6s)
                         wait(AI_CONFIG.BLOCK_DURATION.min + rand(AI_CONFIG.BLOCK_DURATION.max - AI_CONFIG.BLOCK_DURATION.min), () => {
                             if (opponent.health > 0) {
                                opponent.setBlock(false)
                             }
                         });
                    }
                }

                if (opponent.isBlocking) return; // AI cannot move or attack while blocking

                // AI Movement Strategy (Spacing)
                
                // Calculate movement direction towards the player
                // If direction > 0 (opponent is right of player), AI needs to move left (-1)
                const moveDir = direction > 0 ? -1 : 1;

                if (distance > AI_CONFIG.OPTIMAL_DISTANCE + 5) {
                    // Move towards player
                    opponent.move(moveDir * opponentData.speed, 0);
                } else if (distance < AI_CONFIG.OPTIMAL_DISTANCE - 5 && chance(AI_CONFIG.RETREAT_CHANCE)) {
                    // Move away from player (backing up slightly)
                     opponent.move(-moveDir * opponentData.speed * AI_CONFIG.RETREAT_SPEED, 0);
                }

                // AI Attack Strategy
                // Check if enough time has passed based on the opponent's attack rate
                if (aiAttackTimer >= opponentData.attackRate) {
                    if (distance < AI_CONFIG.ATTACK_RANGE) {
                        aiAttackTimer = 0; // Reset timer
                        // Randomly choose punch or kick, influenced slightly by aggression
                        const isKick = chance(0.4 + opponentData.aggression * 0.1);
                        opponent.attack(isKick);
                    }
                }
            });
        });

        // 4. Game Over Scene
        scene("gameOver", () => {
            addCenteredText("GAME OVER", 64, height() / 3, { color: [255, 0, 0] });
            addCenteredText("The streets have defeated you.", 24, height() / 2);
            addCenteredText("Press R to Restart the Quest", 24, height() * 0.75);

            onKeyPress("r", () => {
                resetGame();
                go("start");
            });
        });

        // 5. Victory Scene
        scene("victory", () => {
            addCenteredText("YOU WIN!", 64, height() / 3, { color: [50, 255, 50] });
            addCenteredText("You have defeated the three street masters. The Overseer is vanquished and peace is restored.", 24, height() / 2, { width: width() - 100 });
            addCenteredText("Press R to Play Again", 24, height() * 0.8);

            onKeyPress("r", () => {
                resetGame();
                go("start");
            });
        });

        // Start the game at the initial scene
        go("start");

    </script>
</body>
</html>
