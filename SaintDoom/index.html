<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SaintDoom: Unholy Retribution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #hud {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 18px;
            font-weight: bold;
            z-index: 100;
            pointer-events: none;
            user-select: none;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
        }
        
        .hud-bar {
            display: inline-block;
            margin: 0 5px;
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border: 2px solid #444;
            white-space: nowrap;
        }
        
        #health {
            color: #ff4444;
            border-color: #ff4444;
        }
        
        #armor {
            color: #4444ff;
            border-color: #4444ff;
        }
        
        #ammo {
            color: #ffff44;
            border-color: #ffff44;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 101;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }
        
        #crosshair::before {
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            transform: translateY(-50%);
        }
        
        #crosshair::after {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            transform: translateX(-50%);
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, #1a0000 0%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 1000;
            color: #fff;
            padding-top: 150px;
        }
        
        #startScreen h1 {
            font-size: 60px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #ff0000;
            font-family: 'Times New Roman', serif;
        }
        
        #startScreen h2 {
            font-size: 24px;
            margin-bottom: 40px;
            color: #888;
        }
        
        #startButton {
            padding: 15px 40px;
            font-size: 24px;
            background: #800000;
            color: #fff;
            border: 2px solid #ff0000;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }
        
        #startButton:hover {
            background: #ff0000;
            box-shadow: 0 0 20px #ff0000;
        }
        
        .quote {
            position: absolute;
            bottom: 40px;
            font-style: italic;
            color: #666;
            font-size: 16px;
        }
        
        #instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            display: none;
            z-index: 99;
        }
        
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1001;
            backdrop-filter: blur(5px);
        }
        
        #pauseMenu h2 {
            font-size: 48px;
            color: #fff;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #ff0000;
            font-family: 'Times New Roman', serif;
        }
        
        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .menu-button {
            background: linear-gradient(135deg, #660000, #330000);
            border: 2px solid #ff0000;
            color: #fff;
            padding: 15px 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            min-width: 250px;
        }
        
        .menu-button:hover {
            background: linear-gradient(135deg, #880000, #440000);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        
        #settingsPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            color: #fff;
            z-index: 1002;
            display: none;
        }
        
        #deathScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(100,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1003;
            font-family: 'Times New Roman', serif;
        }
        
        #deathScreen h2 {
            font-size: 72px;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #880000;
            margin-bottom: 20px;
        }
        
        #settingsPanel h3 {
            margin-bottom: 20px;
            color: #ff0000;
        }
        
        #settingsPanel label {
            display: block;
            margin-bottom: 15px;
        }
        
        #settingsPanel input[type="range"] {
            width: 200px;
            vertical-align: middle;
            margin-left: 10px;
        }
        
        .settings-value {
            display: inline-block;
            width: 40px;
            text-align: right;
            margin-left: 10px;
        }
        
        #creditsScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #000000, #1a0000);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        /* Loading Screen Styles */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a0000 0%, #000000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-family: 'Courier New', monospace;
        }
        
        .loading-content {
            text-align: center;
            color: #fff;
        }
        
        #loadingScreen h2 {
            font-size: 48px;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #880000;
            margin-bottom: 30px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading-bar-container {
            width: 400px;
            height: 30px;
            border: 2px solid #ff0000;
            background: #1a0000;
            margin: 0 auto 20px;
            position: relative;
            overflow: hidden;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ff0000;
        }
        
        #loadingText {
            color: #ffaaaa;
            font-size: 18px;
            margin-bottom: 30px;
            animation: fadeInOut 2s infinite;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        .loading-tips {
            margin-top: 40px;
            padding: 20px;
            border-top: 1px solid #440000;
            max-width: 500px;
        }
        
        #loadingTip {
            color: #888;
            font-size: 14px;
            font-style: italic;
        }
        
        #creditsScreen h2 {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #ff0000;
            font-family: 'Times New Roman', serif;
        }
        
        #levelSelectScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #000000, #1a0000);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2000;
        }
        
        #levelSelectScreen h2 {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #ff0000;
            font-family: 'Times New Roman', serif;
        }
        
        .level-select-btn {
            min-width: 350px;
            margin: 5px;
        }
        
        .level-select-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="pauseMenu">
        <h2>PAUSED</h2>
        <div class="menu-options">
            <button class="menu-button" id="resumeButton">Resume</button>
            <button class="menu-button" id="restartButton">Restart Level</button>
            <button class="menu-button" id="settingsButton">Settings</button>
            <button class="menu-button" id="quitButton">Quit to Title</button>
        </div>
    </div>
    
    <div id="settingsPanel">
        <h3>Settings</h3>
        <label>
            Mouse Sensitivity: 
            <input type="range" id="mouseSensitivity" min="1" max="20" value="8">
            <span class="settings-value" id="sensitivityValue">8</span>
        </label>
        <label>
            Volume: 
            <input type="range" id="volume" min="0" max="100" value="50">
            <span class="settings-value" id="volumeValue">50%</span>
        </label>
        <button class="menu-button" id="closeSettings">Close</button>
    </div>
    
    <div id="deathScreen" style="display:none;">
        <h2>YOU HAVE FALLEN</h2>
        <p style="color: #ccc; margin: 20px 0;">But death is merely an inconvenience...</p>
        <div class="menu-options">
            <button class="menu-button" id="respawnButton">RISE AGAIN</button>
            <button class="menu-button" id="deathQuitButton">RETURN TO TITLE</button>
        </div>
    </div>
    
    <div id="startScreen">
        <h1>SAINTDOOM</h1>
        <h2>Unholy Retribution</h2>
        <div class="menu-options" style="display:none;">
            <button class="menu-button" id="startButton">BEGIN CRUSADE</button>
            <button class="menu-button" id="levelSelectButton">LEVEL SELECT</button>
            <button class="menu-button" id="loadButton" style="display:none;">Continue</button>
            <button class="menu-button" id="mainSettingsButton">Settings</button>
            <button class="menu-button" id="creditsButton">Credits</button>
        </div>
        <div class="quote">"Seven times called, seven times I answer."</div>
    </div>
    
    <div id="levelSelectScreen" style="display:none;">
        <h2>LEVEL SELECT</h2>
        <div class="menu-options" style="max-height: 400px; overflow-y: auto;">
            <button class="menu-button level-select-btn" data-level="tutorial">Tutorial - Vatican Inquisition</button>
            <button class="menu-button level-select-btn" data-level="chapel">Chapter 1 - Desecrated Chapel</button>
            <button class="menu-button level-select-btn" data-level="armory">Chapter 2 - The Armory</button>
            <button class="menu-button level-select-btn" data-level="laboratory">Chapter 3 - Laboratory Complex</button>
            <button class="menu-button level-select-btn" data-level="containment">Chapter 4 - Containment Area</button>
            <button class="menu-button level-select-btn" data-level="tunnels">Chapter 5 - Tunnel Network</button>
            <button class="menu-button level-select-btn" data-level="spawning">Chapter 6 - Spawning Grounds</button>
            <button class="menu-button level-select-btn" data-level="observatory">Chapter 7 - Observatory Tower</button>
            <button class="menu-button level-select-btn" data-level="communications">Chapter 8 - Communications Tower</button>
            <button class="menu-button level-select-btn" data-level="reactor">Chapter 9 - Reactor Core</button>
            <button class="menu-button level-select-btn" data-level="finalarena">Chapter 10 - Final Arena</button>
            <hr style="border-color: #444; margin: 10px 0;">
            <button class="menu-button level-select-btn" data-level="archive" style="color: #ffaa00;">SECRET - Forbidden Archive</button>
            <button class="menu-button level-select-btn" data-level="techfacility" style="color: #ffaa00;">SECRET - Black Site Omega</button>
            <button class="menu-button" id="backToMenuBtn">Back to Menu</button>
        </div>
        <div style="color: #666; margin-top: 20px; font-size: 14px;">
            <p id="levelDescription">Select a level to begin</p>
        </div>
    </div>
    
    <div id="creditsScreen" style="display:none;">
        <h2>Credits</h2>
        <div style="color: #888; text-align: center; max-width: 600px; margin: 20px auto;">
            <p>A DOOM-inspired FPS with a holy twist</p>
            <p style="margin-top: 20px;">Built with Three.js</p>
            <p style="margin-top: 40px; font-style: italic;">"Through seven deaths, the Saint achieves martyrdom,<br/>
            and Hell itself shall learn to fear the righteous."</p>
        </div>
        <button class="menu-button" id="backFromCredits">Back</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="crosshair"></div>
    
    <div id="hud">
        <div id="health" class="hud-bar">HEALTH: <span id="healthValue">100</span></div>
        <div id="armor" class="hud-bar">ARMOR: <span id="armorValue">0</span></div>
        <div id="ammo" class="hud-bar">BLESSED: ∞</div>
        <div id="rage" class="hud-bar" style="border-color: #ff00ff;">HOLY RAGE: <span id="rageValue">0</span>%</div>
    </div>
    
    <!-- Top HUD elements -->
    <div style="position: fixed; top: 10px; right: 10px; z-index: 100; pointer-events: none;">
        <div id="level" class="hud-bar" style="border-color: #00ffff; color: #00ffff;">LEVEL: <span id="levelValue">1</span></div>
    </div>
    
    <div style="position: fixed; top: 60px; right: 10px; z-index: 100; pointer-events: none;">
        <div id="score" class="hud-bar" style="border-color: #ffff00; color: #ffff00;">SCORE: <span id="scoreValue">0</span></div>
    </div>
    
    <div style="position: fixed; top: 110px; right: 10px; z-index: 100; pointer-events: none;">
        <div id="kills" class="hud-bar" style="border-color: #ff8800; color: #ff8800;">KILLS: <span id="killsValue">0</span></div>
    </div>
    
    <div id="instructions" style="position: fixed; top: 170px; left: 10px;">
        WASD - Move<br>
        Mouse - Look<br>
        Left Click - Attack<br>
        Right Click - Block (Sword)<br>
        1 - Holy Sword<br>
        2 - Blessed Shotgun<br>
        3 - Holy Water Grenades<br>
        4 - Crucifix Launcher<br>
        R - Holy Rage (when full)<br>
        Shift - Sprint<br>
        ESC - Pause
    </div>
    
    <div id="clickToResume" style="display:none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; text-shadow: 2px 2px 4px black; z-index: 100; pointer-events: none;">
        Click to Resume
    </div>
    
    <!-- Loading Screen -->
    <div id="loadingScreen" style="display:none;">
        <div class="loading-content">
            <h2>LOADING</h2>
            <div class="loading-bar-container">
                <div class="loading-bar"></div>
            </div>
            <p id="loadingText">Preparing holy weapons...</p>
            <div class="loading-tips">
                <p id="loadingTip">TIP: Use holy water grenades to create safe zones</p>
            </div>
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <script type="module" src="main.js"></script>
    <script type="module">
        import { NarrativeSystem } from './narrative.js';
        import { PossessedScientist } from './enemies/possessedScientist.js';
        import { Hellhound } from './enemies/hellhound.js';
        import { InputManager } from './modules/InputManager.js';
        import { Player } from './modules/Player.js';
        // Enemy class removed - now using BaseEnemy from core/BaseEnemy.js
        import { CollisionSystem } from './modules/CollisionSystem.js';
        import { Level } from './level.js';
        import { GAME_CONFIG } from './modules/GameConfig.js';
        import { AudioManager, GeometryCache, MeshFactory, ParticleSystem, VectorUtils } from './modules/Utils.js';
        import { Game } from './modules/Game.js';
        import { TransitionZoneFactory } from './modules/TransitionZones.js';
        import { FacilityMap } from './modules/FacilityMap.js';
        
        // Note: avoiding window.* globals to keep modules self-contained
        // Don't signal modules loaded here - wait for the async module loading to complete
    </script>
    <script type="module">
import { Game } from './modules/Game.js';
// ============= Classes imported from modules =============
// InputManager and Player are now imported from ./modules/


// ============= PICKUPS =============
// Moved to modules/Pickup.js

// Hellhound class moved to enemies/hellhound.js

// Enemy class moved to enemy.js module
// Note: The index.html version used GAME_CONFIG which needs to be reconciled

// ============= WEAPON SYSTEM =============
// Weapon classes moved to modules/WeaponSystem.js

// ============= LEVEL =============
/* Inline Level fallback (deprecated). Use level.js instead.
class Level {
    constructor(scene) {
        this.scene = scene;
        this.walls = [];
        this.exitDoor = null;
        this.exitPosition = null;
        this.levelNumber = 1;
        this.isExitOpen = false;
    }
    
    createTestLevel() {
        // Ensure walls array is clean
        this.walls = [];
        
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x444444,
            roughness: 0.9,
            metalness: 0.1
        });
        
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x666655,
            roughness: 0.8,
            metalness: 0.2
        });
        
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        this.scene.add(floor);
        
        const ceiling = new THREE.Mesh(floorGeometry, wallMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = 3;
        ceiling.receiveShadow = true;
        this.scene.add(ceiling);
        
        this.createWall(-10, 1.5, 0, 1, 3, 20, wallMaterial);
        this.createWall(10, 1.5, 0, 1, 3, 20, wallMaterial);
        this.createWall(0, 1.5, -10, 20, 3, 1, wallMaterial);
        this.createWall(0, 1.5, 10, 20, 3, 1, wallMaterial);
        
        this.createWall(-3, 1.5, -3, 0.2, 3, 6, wallMaterial);
        this.createWall(3, 1.5, -3, 0.2, 3, 6, wallMaterial);
        this.createWall(0, 1.5, 3, 4, 3, 0.2, wallMaterial);
        
        // Create exit door
        this.createExitDoor(0, 1.5, -9.8);
        
        this.addLighting();
    }
    
    createWall(x, y, z, width, height, depth, material) {
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const wall = new THREE.Mesh(geometry, material);
        wall.position.set(x, y, z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        this.scene.add(wall);
        
        this.walls.push({
            mesh: wall,
            min: new THREE.Vector3(
                x - width / 2,
                y - height / 2,
                z - depth / 2
            ),
            max: new THREE.Vector3(
                x + width / 2,
                y + height / 2,
                z + depth / 2
            )
        });
    }
    
    createExitDoor(x, y, z) {
        this.exitDoor = new THREE.Group();
        
        // Create stone door frame
        const frameGroup = new THREE.Group();
        
        // Left frame pillar
        const pillarGeometry = new THREE.BoxGeometry(0.5, 3.5, 0.5);
        const stoneMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.9,
            metalness: 0.1
        });
        
        const leftPillar = new THREE.Mesh(pillarGeometry, stoneMaterial);
        leftPillar.position.x = -1.5;
        frameGroup.add(leftPillar);
        
        const rightPillar = new THREE.Mesh(pillarGeometry, stoneMaterial);
        rightPillar.position.x = 1.5;
        frameGroup.add(rightPillar);
        
        // Top frame
        const topFrameGeometry = new THREE.BoxGeometry(3.5, 0.5, 0.5);
        const topFrame = new THREE.Mesh(topFrameGeometry, stoneMaterial);
        topFrame.position.y = 1.75;
        frameGroup.add(topFrame);
        
        // Create actual door panels
        const doorLeftGeometry = new THREE.BoxGeometry(1.2, 3, 0.15);
        const doorRightGeometry = new THREE.BoxGeometry(1.2, 3, 0.15);
        
        const doorMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a2c17,  // Dark wood color
            roughness: 0.7,
            metalness: 0.1,
            emissive: this.isExitOpen ? 0x00ff00 : 0x440000,
            emissiveIntensity: this.isExitOpen ? 0.3 : 0.1
        });
        
        this.doorLeft = new THREE.Mesh(doorLeftGeometry, doorMaterial);
        this.doorLeft.position.x = -0.6;
        this.doorLeft.name = 'doorLeft';
        
        this.doorRight = new THREE.Mesh(doorRightGeometry, doorMaterial);
        this.doorRight.position.x = 0.6;
        this.doorRight.name = 'doorRight';
        
        // Add metal reinforcements to doors
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.3,
            metalness: 0.8
        });
        
        // Horizontal metal bands
        for (let i = -1; i <= 1; i++) {
            const bandGeometry = new THREE.BoxGeometry(1.1, 0.1, 0.16);
            const leftBand = new THREE.Mesh(bandGeometry, metalMaterial);
            leftBand.position.set(-0.6, i * 0.8, 0);
            this.exitDoor.add(leftBand);
            
            const rightBand = new THREE.Mesh(bandGeometry, metalMaterial);
            rightBand.position.set(0.6, i * 0.8, 0);
            this.exitDoor.add(rightBand);
        }
        
        // Add holy seal in center (glows when locked)
        const sealGeometry = new THREE.CircleGeometry(0.4, 16);
        const sealMaterial = new THREE.MeshStandardMaterial({
            color: this.isExitOpen ? 0x00ff00 : 0xff0000,
            emissive: this.isExitOpen ? 0x00ff00 : 0xff0000,
            emissiveIntensity: 0.5,
            side: THREE.DoubleSide,
            roughness: 0.3,
            metalness: 0.2
        });
        
        this.seal = new THREE.Mesh(sealGeometry, sealMaterial);
        this.seal.position.z = -0.08;
        this.seal.name = 'seal';
        
        // Add cross to seal
        const crossMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            emissive: 0xffff00,
            emissiveIntensity: 0.8,
            roughness: 0.2,
            metalness: 0.3
        });
        
        const vertBar = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.5, 0.01),
            crossMaterial
        );
        vertBar.position.z = -0.09;
        
        const horizBar = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.05, 0.01),
            crossMaterial
        );
        horizBar.position.y = 0.1;
        horizBar.position.z = -0.09;
        
        // Add door handles
        const handleGeometry = new THREE.TorusGeometry(0.15, 0.02, 8, 16);
        const handleMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B7355,
            roughness: 0.3,
            metalness: 0.7
        });
        
        const leftHandle = new THREE.Mesh(handleGeometry, handleMaterial);
        leftHandle.position.set(-0.3, 0, -0.1);
        this.doorLeft.add(leftHandle);
        
        const rightHandle = new THREE.Mesh(handleGeometry, handleMaterial);
        rightHandle.position.set(0.3, 0, -0.1);
        this.doorRight.add(rightHandle);
        
        // Assemble door
        this.exitDoor.add(frameGroup);
        this.exitDoor.add(this.doorLeft);
        this.exitDoor.add(this.doorRight);
        this.exitDoor.add(this.seal);
        this.exitDoor.add(vertBar);
        this.exitDoor.add(horizBar);
        
        this.exitDoor.position.set(x, y, z);
        this.scene.add(this.exitDoor);
        
        this.exitPosition = new THREE.Vector3(x, 0, z);
        
        // Add glowing effect animation
        this.animateExitDoor();
    }
    
    animateExitDoor() {
        const seal = this.exitDoor.getObjectByName('seal');
        if (!seal) return;
        
        const animate = () => {
            if (this.isExitOpen) {
                // Pulse green when open
                const pulse = Math.sin(Date.now() * 0.003) * 0.5 + 0.5;
                seal.material.emissiveIntensity = 0.3 + pulse * 0.4;
                seal.rotation.z += 0.01; // Rotate seal when open
            } else {
                // Subtle red pulse when closed
                const pulse = Math.sin(Date.now() * 0.002) * 0.5 + 0.5;
                seal.material.emissiveIntensity = 0.2 + pulse * 0.2;
            }
            
            requestAnimationFrame(animate);
        };
        animate();
    }
    
    openExitDoor() {
        this.isExitOpen = true;
        
        // Change seal color to green
        const seal = this.exitDoor ? this.exitDoor.getObjectByName('seal') : null;
        if (seal && seal.material) {
            seal.material.color.setHex(0x00ff00);
            if (seal.material.emissive) {
                seal.material.emissive.setHex(0x00ff00);
                seal.material.emissiveIntensity = 0.5;
            }
        }
        
        // Animate doors opening
        const doorLeft = this.exitDoor ? this.exitDoor.getObjectByName('doorLeft') : null;
        const doorRight = this.exitDoor ? this.exitDoor.getObjectByName('doorRight') : null;
        
        if (doorLeft && doorRight && doorLeft.material && doorRight.material) {
            // Change door material to show they're unlocked
            if (doorLeft.material.emissive) {
                doorLeft.material.emissive.setHex(0x00ff00);
                doorLeft.material.emissiveIntensity = 0.2;
            }
            if (doorRight.material.emissive) {
                doorRight.material.emissive.setHex(0x00ff00);
                doorRight.material.emissiveIntensity = 0.2;
            }
            
            // Animate doors swinging open
            const openAnimation = () => {
                if (doorLeft.rotation.y > -Math.PI / 3) {
                    doorLeft.rotation.y -= 0.02;
                    doorRight.rotation.y += 0.02;
                    requestAnimationFrame(openAnimation);
                }
            };
            openAnimation();
        }
        
        // Add floating arrow indicator above door
        this.createExitIndicator();
        
        // Add bright light at exit
        if (this.exitPosition) {
            const exitLight = new THREE.PointLight(0x00ff00, 2, 15);
            exitLight.position.copy(this.exitPosition);
            exitLight.position.y = 2;
            this.scene.add(exitLight);
        }
        
        // Play door open sound
        this.playDoorOpenSound();
    }
    
    createExitIndicator() {
        // Only create indicator if exit position exists
        if (!this.exitPosition) return;
        
        // Create a floating arrow pointing down
        const arrowGroup = new THREE.Group();
        
        // Arrow shaft
        const shaftGeometry = new THREE.BoxGeometry(0.2, 1.5, 0.2);
        const arrowMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 1,
            roughness: 0.3,
            metalness: 0.2
        });
        const shaft = new THREE.Mesh(shaftGeometry, arrowMaterial);
        shaft.position.y = 0.5;
        arrowGroup.add(shaft);
        
        // Arrow head (cone)
        const headGeometry = new THREE.ConeGeometry(0.5, 0.8, 4);
        const head = new THREE.Mesh(headGeometry, arrowMaterial);
        head.position.y = -0.5;
        head.rotation.z = Math.PI;
        arrowGroup.add(head);
        
        // Position above door
        arrowGroup.position.copy(this.exitPosition);
        arrowGroup.position.y = 4.5;
        
        this.scene.add(arrowGroup);
        
        // Animate bobbing
        const animate = () => {
            arrowGroup.position.y = 4.5 + Math.sin(Date.now() * 0.003) * 0.3;
            arrowGroup.rotation.y += 0.02;
            requestAnimationFrame(animate);
        };
        animate();
    }
    
    playDoorOpenSound() {
        const audioContext = AudioManager.getContext();
        if (!audioContext) return; // Exit if no audio context
        
        // Heavenly chord sound
        const frequencies = [261.63, 329.63, 392.00]; // C major chord
        const oscillators = [];
        const gainNode = audioContext.createGain();
        
        frequencies.forEach(freq => {
            const osc = audioContext.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, audioContext.currentTime);
            osc.connect(gainNode);
            oscillators.push(osc);
        });
        
        gainNode.connect(audioContext.destination);
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
        
        oscillators.forEach(osc => {
            osc.start();
            osc.stop(audioContext.currentTime + 2);
        });
    }
    
    checkExitCollision(player) {
        if (!this.isExitOpen || !this.exitPosition) return false;
        
        const distance = player.position.distanceTo(this.exitPosition);
        return distance < 2; // Within 2 units of door
    }
    
    createNextLevel() {
        this.clearLevel();
        this.levelNumber++;
        this.isExitOpen = false;
        
        if (this.levelNumber === 2) {
            this.createLevel2();
        } else if (this.levelNumber === 3) {
            this.createBossLevel();
        } else {
            // Loop back or create procedural levels
            this.createTestLevel();
        }
    }
    
    createLevel2() {
        // Completely clear the scene of walls
        const toRemove = [];
        this.scene.traverse(child => {
            if (child.isMesh && (child.geometry instanceof THREE.BoxGeometry || 
                child.geometry instanceof THREE.PlaneGeometry)) {
                // Keep only essential elements
                if (child !== this.camera) {
                    toRemove.push(child);
                }
            }
        });
        toRemove.forEach(child => this.scene.remove(child));
        
        // Reset walls array
        this.walls = [];
        
        // Level 2 materials
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x333344,
            roughness: 0.9,
            metalness: 0.1
        });
        
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x554455,
            roughness: 0.8,
            metalness: 0.2
        });
        
        // Create floor and ceiling
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        this.scene.add(floor);
        
        const ceiling = new THREE.Mesh(floorGeometry, wallMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = 3;
        ceiling.receiveShadow = true;
        this.scene.add(ceiling);
        
        // Create perimeter walls only - no invisible walls
        this.createWall(-15, 1.5, 0, 0.5, 3, 30, wallMaterial);  // Left wall
        this.createWall(15, 1.5, 0, 0.5, 3, 30, wallMaterial);   // Right wall
        this.createWall(0, 1.5, -15, 30, 3, 0.5, wallMaterial);  // Back wall  
        this.createWall(0, 1.5, 15, 30, 3, 0.5, wallMaterial);   // Front wall
        
        // Create simple interior obstacles (not blocking path to exit)
        this.createWall(-8, 1.5, -8, 3, 3, 3, wallMaterial);     // Top-left pillar
        this.createWall(8, 1.5, -8, 3, 3, 3, wallMaterial);      // Top-right pillar
        this.createWall(-8, 1.5, 8, 3, 3, 3, wallMaterial);      // Bottom-left pillar
        this.createWall(8, 1.5, 8, 3, 3, 3, wallMaterial);       // Bottom-right pillar
        
        // Central cover - moved slightly back to avoid spawn position
        this.createWall(0, 1.5, -3, 2, 3, 2, wallMaterial);       // Center pillar
        
        // Exit door - make sure it's accessible
        this.createExitDoor(0, 1.5, -14.5);
        
        this.addLighting();
    }
    
    createBossLevel() {
        // Clear walls array for boss level
        this.walls = [];
        
        // Boss arena - large open space
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x220000,
            roughness: 0.9,
            metalness: 0.1
        });
        
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x440000,
            roughness: 0.8,
            metalness: 0.2
        });
        
        // Large circular arena
        const floorGeometry = new THREE.PlaneGeometry(40, 40);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        this.scene.add(floor);
        
        const ceiling = new THREE.Mesh(floorGeometry, wallMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = 5; // Higher ceiling for boss
        ceiling.receiveShadow = true;
        this.scene.add(ceiling);
        
        // Circular walls (approximated with segments)
        const segments = 16;
        const radius = 20;
        for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const rotation = -angle;
            
            const wall = new THREE.Mesh(
                new THREE.BoxGeometry(3, 5, 1),
                wallMaterial
            );
            wall.position.set(x, 2.5, z);
            wall.rotation.y = rotation;
            wall.castShadow = true;
            wall.receiveShadow = true;
            this.scene.add(wall);
            
            // Store wall bounds
            this.walls.push({
                mesh: wall,
                min: new THREE.Vector3(x - 1.5, 0, z - 0.5),
                max: new THREE.Vector3(x + 1.5, 5, z + 0.5)
            });
        }
        
        // Add pillars for cover
        const pillarPositions = [
            { x: -10, z: -10 },
            { x: 10, z: -10 },
            { x: -10, z: 10 },
            { x: 10, z: 10 }
        ];
        
        pillarPositions.forEach(pos => {
            this.createWall(pos.x, 2.5, pos.z, 2, 5, 2, wallMaterial);
        });
        
        // Exit door (initially locked until boss defeated)
        this.createExitDoor(0, 2.5, -19.5);
        
        // Dramatic lighting for boss arena
        this.addBossLighting();
    }
    
    addBossLighting() {
        // Red ominous lighting
        const redLight = new THREE.PointLight(0xff0000, 2, 30);
        redLight.position.set(0, 4, 0);
        this.scene.add(redLight);
        
        // Flickering torches around arena
        const torchPositions = [
            { x: -15, y: 3, z: -15 },
            { x: 15, y: 3, z: -15 },
            { x: -15, y: 3, z: 15 },
            { x: 15, y: 3, z: 15 },
            { x: 0, y: 3, z: -18 },
            { x: 0, y: 3, z: 18 }
        ];
        
        torchPositions.forEach((pos, index) => {
            const light = new THREE.PointLight(0xff4400, 1, 10);
            light.position.set(pos.x, pos.y, pos.z);
            // Only enable shadows for first 2 lights to avoid exceeding texture units
            if (index < 2) {
                light.castShadow = true;
            }
            this.scene.add(light);
        });
    }
    
    clearLevel() {
        // Remove all level geometry
        this.walls.forEach(wall => {
            this.scene.remove(wall.mesh);
        });
        
        if (this.exitDoor) {
            this.scene.remove(this.exitDoor);
        }
        
        // Clear all children except camera and main directional light
        const toRemove = [];
        this.scene.traverse(child => {
            // Remove meshes, point lights, and groups (but keep the main directional light)
            if ((child.type === 'Mesh' || child.type === 'PointLight' || child.type === 'Group') 
                && child !== this.scene && child !== this.camera) {
                toRemove.push(child);
            }
        });
        
        toRemove.forEach(child => {
            this.scene.remove(child);
        });
        
        this.walls = [];
        this.exitDoor = null;
        this.exitPosition = null;
    }
    
    addLighting() {
        const torchPositions = [
            { x: -9, y: 2, z: -9 },
            { x: 9, y: 2, z: -9 },
            { x: -9, y: 2, z: 9 },
            { x: 9, y: 2, z: 9 }
        ];
        
        torchPositions.forEach((pos, index) => {
            const light = new THREE.PointLight(0xffaa00, 1, 10);
            light.position.set(pos.x, pos.y, pos.z);
            // Only enable shadows for first 2 lights to avoid exceeding texture units
            if (index < 2) {
                light.castShadow = true;
            }
            this.scene.add(light);
        });
    }
}

*/
// CollisionSystem class moved to modules/CollisionSystem.js

// ============= MAIN GAME CLASS MOVED TO modules/Game.js =============

// Make Pickup class available globally

// ============= START GAME =============
window.addEventListener('DOMContentLoaded', () => {
    // Wait for modules to load
    let game;
    
    // Main start button
    document.getElementById('startButton').addEventListener('click', () => {
        const initGame = () => {
            // Initialize audio context on user interaction
            if (window.AudioManager && window.AudioManager.audioSystem) {
                window.AudioManager.audioSystem.initAudioContext();
            }
            
            // Create game instance if it doesn't exist
            if (!game) {
                game = new Game();
            }
            
            game.init('tutorial');
        };
        
        if (window.modulesLoaded) {
            initGame();
        } else {
            window.addEventListener('modulesLoaded', initGame, { once: true });
        }
    });
    
    // Level select button
    document.getElementById('levelSelectButton').addEventListener('click', () => {
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('levelSelectScreen').style.display = 'flex';
        
        // Check unlocked levels (stored in localStorage)
        // FOR TESTING: All levels unlocked
        const unlockedLevels = ["tutorial", "chapel", "armory", "laboratory", "containment", 
                               "tunnels", "spawning", "observatory", "communications", 
                               "reactor", "finalarena", "archive", "techfacility"];
        // const unlockedLevels = JSON.parse(localStorage.getItem('unlockedLevels') || '["tutorial", "chapel"]');
        document.querySelectorAll('.level-select-btn').forEach(btn => {
            const level = btn.dataset.level;
            if (!unlockedLevels.includes(level)) {
                btn.disabled = true;
                btn.textContent += ' (Locked)';
            }
        });
    });
    
    // Level select buttons
    document.querySelectorAll('.level-select-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const levelName = e.target.dataset.level;
            document.getElementById('levelSelectScreen').style.display = 'none';
            
            // Wait for modules to load before initializing
            const initGame = () => {
                // Initialize audio context on user interaction
                if (window.AudioManager && window.AudioManager.audioSystem) {
                    window.AudioManager.audioSystem.initAudioContext();
                }
                
                // Create game instance if it doesn't exist
                if (!game) {
                    game = new Game();
                }
                
                game.init(levelName);
            };
            
            if (window.modulesLoaded) {
                initGame();
            } else {
                window.addEventListener('modulesLoaded', initGame, { once: true });
            }
        });
    });
    
    // Back to menu button
    document.getElementById('backToMenuBtn').addEventListener('click', () => {
        document.getElementById('levelSelectScreen').style.display = 'none';
        document.getElementById('startScreen').style.display = 'flex';
    });
    
    window.addEventListener('resize', () => {
        if (game && game.camera && game.renderer) {
            game.camera.aspect = window.innerWidth / window.innerHeight;
            game.camera.updateProjectionMatrix();
            game.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });
    
    // Pause menu handling
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && game && game.isRunning && !game.gameOver) {
            // Don't do anything here - let pointerlockchange handle it
            // game.togglePause();
        }
    });
    
    // Handle pointer lock changes to detect ESC press
    document.addEventListener('pointerlockchange', () => {
        const isLocked = document.pointerLockElement === document.body;
        
        // If pointer lock was just released and game is running (not paused), show pause menu
        if (!isLocked && game && game.isRunning && !game.isPaused && !game.gameOver) {
            game.isPaused = true;
            document.getElementById('pauseMenu').style.display = 'flex';
        }
    });
    
    // Main menu buttons
    document.getElementById('mainSettingsButton').addEventListener('click', () => {
        document.getElementById('settingsPanel').style.display = 'flex';
    });
    
    document.getElementById('creditsButton').addEventListener('click', () => {
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('creditsScreen').style.display = 'flex';
    });
    
    document.getElementById('backFromCredits').addEventListener('click', () => {
        document.getElementById('creditsScreen').style.display = 'none';
        document.getElementById('startScreen').style.display = 'flex';
    });
    
    // Pause menu buttons
    document.getElementById('resumeButton').addEventListener('click', () => {
        if (game) game.togglePause();
    });
    
    document.getElementById('restartButton').addEventListener('click', () => {
        if (game) game.restartLevel();
    });
    
    document.getElementById('settingsButton').addEventListener('click', () => {
        document.getElementById('settingsPanel').style.display = 'flex';
    });
    
    document.getElementById('quitButton').addEventListener('click', () => {
        if (game) game.quitToTitle();
    });
    
    // Death screen buttons
    document.getElementById('respawnButton').addEventListener('click', () => {
        document.getElementById('deathScreen').style.display = 'none';
        if (game) game.respawnPlayer();
    });
    
    document.getElementById('deathQuitButton').addEventListener('click', () => {
        document.getElementById('deathScreen').style.display = 'none';
        if (game) game.quitToTitle();
    });
    
    // Settings panel
    document.getElementById('closeSettings').addEventListener('click', () => {
        document.getElementById('settingsPanel').style.display = 'none';
    });
    
    document.getElementById('mouseSensitivity').addEventListener('input', (e) => {
        const value = e.target.value;
        document.getElementById('sensitivityValue').textContent = value;
        if (game && game.player) {
            game.player.mouseSensitivity = parseFloat(value) * 0.001;
        }
    });
    
    document.getElementById('volume').addEventListener('input', (e) => {
        const value = e.target.value;
        document.getElementById('volumeValue').textContent = value + '%';
        // Would apply to audio system if implemented
    });
});
    </script>
    
    <!-- Load essential modules only -->
    <script type="module">
        // Only load critical modules at startup, levels will be loaded on demand
        async function loadModules() {
            try {
                // Load core systems
                const { NarrativeSystem } = await import('./narrative.js');
                const { AudioSystem } = await import('./audio/audioSystem.js');
                
                // Load common enemies (used in multiple levels)
                const { PossessedScientist } = await import('./enemies/possessedScientist.js');
                const { Hellhound } = await import('./enemies/hellhound.js');
        
        // Create global audio system instance
        const audioSystem = new AudioSystem();
        
        // Create AudioManager wrapper for backward compatibility
        window.AudioManager = {
            audioSystem: audioSystem,
            
            getContext() {
                // Initialize context if needed
                if (!audioSystem.audioContext) {
                    audioSystem.initAudioContext();
                }
                return audioSystem.audioContext;
            },
            
            playPickupSound() {
                audioSystem.playSoundEffect('pickup');
            },
            
            playAmmoSound() {
                audioSystem.playSoundEffect('pickup');
            },
            
            playArmorSound() {
                audioSystem.playSoundEffect('pickup');
            },
            
            playSwordSwing() {
                audioSystem.playSoundEffect('swordSwing');
            },
            
            playSwordHit() {
                audioSystem.playSoundEffect('swordHit');
            },
            
            playBlock() {
                audioSystem.playSoundEffect('block');
            },
            
            playHurt() {
                audioSystem.playSoundEffect('hurt');
            },
            
            playDeath() {
                audioSystem.playSoundEffect('death');
            },
            
            playVoiceLine(category) {
                audioSystem.playVoiceLine(category);
            },
            
            playRageSound() {
                audioSystem.playSoundEffect('holyCharge');
            }
        };
        
        // Make core modules available globally
        window.NarrativeSystem = NarrativeSystem;
        window.PossessedScientist = PossessedScientist;
        window.Hellhound = Hellhound;
        window.AudioSystem = AudioSystem;
        
        console.log('Core modules loaded successfully');
        console.log('Levels will be loaded on demand for faster startup');
        
        // Set flag to indicate modules are loaded
        window.modulesLoaded = true;
        window.dispatchEvent(new Event('modulesLoaded'));
        
        // Show menu buttons now that modules are loaded
        const menuOptions = document.querySelector('#startScreen .menu-options');
        if (menuOptions) {
            menuOptions.style.display = 'flex';
        }
            } catch (error) {
                console.error('Error loading modules:', error);
            }
        }
        
        // Call the async function and wait for it
        loadModules();
    </script>
</body>
</html>
